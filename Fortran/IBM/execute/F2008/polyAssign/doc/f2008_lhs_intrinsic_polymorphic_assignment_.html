<html><head><title>F2008 LHS intrinsic polymorphic assignment</title></head><body><table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#c0e1ff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="left" style="font-family: Arial; color: rgb(0, 0, 128); font-size: 12pt;"><strong>Document Control Information:</strong>
            <p style="color: rgb(0, 0, 0);">The official version of this document is kept in CMVC in the <span style="font-weight: bold; text-decoration: underline;">%CMVC_Family%</span> family, release <span style="font-weight: bold; text-decoration: underline;">%CMVC_Release%</span>, component <span style="font-weight: bold; text-decoration: underline;">%CMVC_Component%</span>, file <span style="color: rgb(255, 102, 102); font-weight: bold; text-decoration: underline;">%CMVC_PathName%</span>. Users of this document are personally responsible for using the official version and for verifying that any copies of the document, in whole or in part, are of the official version. If this document is not a copy of the official version, it is obsolete.<br />
            <br />
            CMVC Extraction Information: %W% %H% %I% sccsid<br />
            <br />
            This document is IBM Confidential.<br />
            </p>
            </td>
        </tr>
    </tbody>
</table>
<br />
<br />
<table cellspacing="0" cellpadding="5" border="1" style="text-align: left; background-color: rgb(224, 255, 191); width: 100%; font-family: Arial; font-size: 12pt;">
    <tbody>
        <tr>
            <td width="20%" valign="top" align="left"><strong>CMVC Feature Number</strong> </td>
            <td width="80%" valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">%CMVC_Feature%</td>
        </tr>
        <tr>
            <td valign="top" align="left"><strong>Feature Title</strong> </td>
            <td valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">%Document_Name% %Note{By default the feature title and document name are the same. You can either change the document name (through Properties), or replace the tag with the title of the feature}%</td>
        </tr>
        <tr>
            <td valign="top" align="left"><strong>Author(s)</strong> </td>
            <td valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">Aaron Liu (%Authors%)</td>
        </tr>
        <tr>
            <td valign="top" align="left"><strong>Applicable Product Releases</strong>       </td>
            <td valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">%Note{ List all the products and their release numbers for which the information in this document is/will be correct. For example:<br />
            XL C/C++ v7.0 and 8.0 on Linux and AIX<br />
            XL Fortran v9.1 and 10.1 on Linux and AIX.<br />
            <br />
            If you are updating this IT1, remove old products from the list if they will not support this updated I0's behaviour. For example, if this IT1 was first written for XL Fortran v9.1 and a change is being made in XL Fortran v10.1 that will not be ported back to v9.1, then v9.1 should not appear in the list.<br />
            <br />
            For prototype or experimental code that isn't scheduled to ship in any release yet, note possible future targets like this: &quot;Experimental code, may ship in future XL Fortran and XL C/C++ AIX releases&quot; }%</td>
        </tr>
        <tr>
            <td valign="top" align="left"><strong>Keyword(s)</strong>       </td>
            <td valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">%Note{ Define KEYWORDS to be used to identify/classify this feature }%</td>
        </tr>
    </tbody>
</table>
<br />
<br />
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#ff6666">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="text-align: left; font-family: Arial; font-size: 12pt;"><strong>IT1 Status</strong> </td>
        </tr>
    </tbody>
</table>
<br />
<p>
<table cellspacing="0" cellpadding="5" border="1" style="text-align: left; background-color: rgb(224, 255, 191); width: 100%; font-family: Arial; font-size: 12pt;">
    <tbody>
        <tr>
            <td valign="top" align="left"><strong>Approvers</strong> (mandatory participation) </td>
            <td valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">%Note{Insert the names of people who will have approval authority for this review. These people, in aggregate, are responsible for approving the technical and user interface content of the document. Generally, this list should include people who represent compiler components that will need to change if this review is approved.<br />
            The I0 Process document provides detailed guidance on choosing your list of approvers.<br />
            A member of the Option Review Board must approve any i0 that adds an option or pragma.<br />
            Use Access Control to add/delete people from this list. The initial access control list is populated with the people from the Component Reviewers section below. You can use Access Control to change their role to Approver, or add additional approvers.}%<br />
            %Approvers%</td>
        </tr>
        <tr>
            <td valign="top" align="left"><strong>Reviewers</strong> (optional participation) </td>
            <td valign="top" align="left" style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 255); font-weight: bold;">%Note{List any additional people you feel need to participate in the review. These people do not have approval authority. Use Access Control to add/delete people from this list.}%<br />
            %Release_Management_Contact%<br />
            %Team_Reviewers%<br />
            %Component_Reviewers%</td>
        </tr>
    </tbody>
</table>
</p>
<p><br />
</p>
<p>
<table cellspacing="2" cellpadding="2" border="1" style="text-align: left; background-color: rgb(224, 255, 191); width: 100%; font-family: Arial; font-size: 12pt;">
    <tbody>
        <tr>
            <td style="font-family: Arial; vertical-align: top;"><strong>Approvers</strong>: Please click the 'Approved' check-box beside your name in the table below if you agree with the technical content of this document; not checking your 'approve' check-box signifies you do not approve.</td>
        </tr>
    </tbody>
</table>
</p>
%Approvals%
<p>Approval Comments</p>
<p><br />
<br />
</p>
<p>
<table cellspacing="2" cellpadding="2" border="1" style="text-align: left; background-color: rgb(224, 255, 191); width: 100%; font-family: Arial; font-size: 12pt;">
    <tbody>
        <tr>
            <td style="font-family: Arial; vertical-align: top;"><strong>Reviewers</strong>: Please click the 'Reviewed' checkbox beside your name to indicate your participation in the review. </td>
        </tr>
    </tbody>
</table>
</p>
<p>%Reviews%</p>
<p>Review Comments</p>
<p><br />
</p>
<p>
<table cellspacing="2" cellpadding="2" border="1" style="text-align: left; background-color: rgb(224, 255, 191); width: 100%; font-family: Arial; font-size: 12pt;">
    <tbody>
        <tr>
            <td style="font-family: Arial; vertical-align: top;"><strong>Access Change History</strong> %Note{Authors: Access Change History will list any changes to the access control done to the document draft. These changes would not be visible in a review. In a review, this section would only list the access changes done to the review itself.<br />
            Please note that changes to the access control of a review are not automatically reflected in the access control of the draft document.}% </td>
        </tr>
    </tbody>
</table>
</p>
<p>%CollapsedSection{<strong>Access Change History</strong>}{%Access_Change_History%}%<br />
</p>
<p>
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#bfbfff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="font-family: Arial; font-size: 12pt;"><strong>Overview</strong> </td>
        </tr>
    </tbody>
</table>
</p>
<p>%Note{A brief description of the feature, its application(s) and limitation(s).<br />
<br />
Feature syntax may also be mentioned here.  Since it is in the I0 document, it is optional.}%<br />
</p>
&nbsp; --------------------------------------------------------------------------------------------------------------<br />
<font size="3">An intrinsic assignment statement is an assignment statement that is not a defined assignment statement.<br />
F2008 standard allows the variable in an intrinsic assignment 'variable = expr' to be polymorphic.<br />
<font size="4"><strong>It posts the following constraints</strong></font> <br />
(1) if the variable is polymorphic it shall be allocatable,<br />
(2) if expr is an array then the variable shall also be an array,<br />
(3) the variable and expr shall be conformable unless the variable is an allocatable array that has the same rank as expr,<br />
(4) if the variable is polymorphic it shall be type compatible with expr.</font><font size="3"><br />
(5) if the variable is of derived type each length type parameter of the variable shall have the same value as the corresponding type parameter of expr.<br />
<br />
Consider the following test case:<br />
<br />
Program test<br />
&nbsp;&nbsp;&nbsp; Type t<br />
&nbsp;&nbsp;&nbsp; End Type<br />
&nbsp;&nbsp;&nbsp; Type,Extends(t) :: t2<br />
&nbsp;&nbsp;&nbsp; End Type<br />
&nbsp;&nbsp;&nbsp; Class(t),Allocatable :: x,y<br />
&nbsp;&nbsp;&nbsp; x = t()<br />
&nbsp;&nbsp;&nbsp; y = t2()<br />
End<br />
<br />
Compiled with XLF2003, it failed and had errors on &quot;The variable being defined in the intrinsic assignment statement must not be polymorphic&quot;.<br />
<br />
We diagnose it according to F2003 that the var of an intrinsic assignment cannot be polymorphic. However, F2008 standard changes it as a valid case and x should be allocated and assigned dynamic type of t and y should be allocated and assigned the dynamic type of t2.<br />
<br />
<font size="4"><strong>Interpretation of intrinsic assignments</strong></font><br />
<br />
(1) Execution of an intrinsic assignment causes, in effect, the evaluation of the expression expr and all expressions within variable, the possible conversion of expr to the type and type parameters of the variable, and the definition of the variable with the resulting value.<br />
(2) If the variable is a pointer, the value of expr is assigned to the target of the variable.<br />
(3) If the variable is an unallocated allocatable array, expr shall have the same rank. If the variable is an allocated allocatable variable, it is deallocated if expr is an array of different shape, any of the corresponding length type parameter values of the variable and expr differ, or the variable is polymorphic and the dynamic type of the variable and expr differ. If the variable is or becomes an unallocated allocatable variable, it is then allocated with<br />
&nbsp;&nbsp;&nbsp; -if the variable is polymorphic, the same dynamic type as expr,<br />
&nbsp;&nbsp;&nbsp; -each deferred type parameter equal to the corresponding type parameter of expr,<br />
&nbsp;&nbsp;&nbsp; -if the variable is an array and expr is scalar, the same bounds as before, and<br />
&nbsp;&nbsp;&nbsp; -if expr is an array, the shape of expr with each lower bound equal to the corresponding element of LBOUND (expr).<br />
<br />
We will need to check if the dynamic type is the same&nbsp; and if the shape for each dimension is the same to decide if we need to deallocate as in the following test case:<br />
<br />
<font face="Courier New">module m<br />
&nbsp;&nbsp; type base<br />
&nbsp;&nbsp; real :: r1<br />
&nbsp;&nbsp; contains<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final :: ff<br />
&nbsp;&nbsp; end type<br />
&nbsp;&nbsp; type, extends(base) :: child<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real :: r2<br />
&nbsp;&nbsp; end type<br />
&nbsp;&nbsp; contains<br />
&nbsp;&nbsp; subroutine ff(arg)<br />
&nbsp;&nbsp; type(base) :: arg<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print*, &quot;infinal&quot;<br />
&nbsp;&nbsp; end<br />
end module<br />
<br />
program polymorphicAssign<br />
&nbsp;&nbsp; use m<br />
&nbsp;&nbsp; class(base), allocatable :: b1(:), b2(:), b3(:), b4(:), b5(:)<br />
&nbsp;&nbsp; allocate(base :: b1(2:11))<br />
&nbsp;&nbsp; allocate(base:: b2(1:10))<br />
&nbsp;&nbsp; allocate(child :: b3(2:11))<br />
&nbsp;&nbsp; allocate(base :: b4(2:12))<br />
&nbsp;&nbsp; allocate(child :: b5(-2:2)) !different types, different bounds.<br />
&nbsp;&nbsp; b1 = b2&nbsp;&nbsp;&nbsp; !! Element by element assignment, but will not reset the lbound and ubound for b1, as their shape is the same.<br />
&nbsp;&nbsp; b1 = b3&nbsp;&nbsp;&nbsp; !! b1 will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound as b3, and get exactly the same copy of b3,</font></font> because the dynamic type is different.<br />
&nbsp;&nbsp; b1 = b4&nbsp;&nbsp;&nbsp; !! </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">b1 will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">ubound as b3, and get exactly the same copy of b3,</font></font></font></font> because of the shape is different.<br />
&nbsp;&nbsp; b1 = b5&nbsp;&nbsp;&nbsp; !! </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">b1 will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound as b3, </font></font></font></font>because the dynamic type and shape are different. This will make b1 get exactly the same copy of b5.<br />
end program<br />
<br />
The algorithm is:<br />
<font size="4">if (allocated(LHS) then<br />
&nbsp;&nbsp; if (sameTypeAs(LHS, RHS) then<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sameShapeAs(LHS, RHS) then<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if (sameExtentAs(LHS, RHS) then<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; LHS = RHS !</font></font></font><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New">Element by element assignment </font></font>but </font></font></font><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound</font></font></font></font></font></font></font> of LHS will not be changed.<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
</font></font></font><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LHS will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound as RHS and get exactly the same copy of RHS</font></font>.</font></font> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />
</font></font></font><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LHS will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound as RHS and get exactly the same copy of RHS</font></font>.</font></font></font></font></font><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if<br />
&nbsp;&nbsp; else<br />
</font></font></font><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LHS will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound as RHS and get exactly the same copy of RHS</font></font>.</font></font></font></font></font></font></font></font><br />
&nbsp;&nbsp; end if<br />
else</font></font></font><br />
<font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New"><font size="4"><font size="3"><font face="Courier New">&nbsp;&nbsp; LHS will be reset for </font></font><font size="3"><font face="Courier New"><font size="3"><font face="Courier New">lbound and ubound as RHS and get exactly the same copy of RHS</font></font>.<br />
</font></font></font></font></font></font></font></font>end if</font></font><br />
</font><br />
<p>
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#bfbfff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="font-family: Arial; font-size: 12pt;"><strong>Test Strategy</strong></td>
        </tr>
    </tbody>
</table>
</p>
%Note{This is the most important section of the document.  <br />
<br />
Detail the test methodology and coverage for the feature to be tested.<br />
<br />
Test strategy is not to identify all possible defects under all conditions with the feature.  In most cases, this is unrealistic.<br />
It is to identify and report defects with the feature under specific conditions likely to be used by the customer.  <br />
As a tester, you are the first customer of the feature.  So you, the tester, need to understand how a certain feature would be used in the real world and come up with a Test strategy to validate those use cases.  <br />
<br />
Use cases to be validated should be documented here.<br />
<br />
Provide examples if they are needed to explain the test method or coverage. <br />
<br />
If applicable, organize the coverage into diagnostic and functional sections.  <br />
<br />
Diagnostic test cases verify error handling of the feature and the corresponding messages that are produced.  This would also include verifying that valid syntax does not produce any unexpected messages.<br />
This type of testing usually fall under the umbrella of unit tests. The developer of the feature is expected to write fully automated unit tests, but this can be negotiated if it is unfeasible for the developer to do so.<br />
<br />
Test cases that verify values are referred to as functional test cases. <br />
<br />
For large features, there may not be resource/time to completely test the feature. Certain parts of the feature will be more important than others.  <br />
Prioritize the test coverage and clearly document what will be covered in testing and what will be omitted.  Risk assessment on the parts omitted should also be documented.  This needs to be reviewed and agreed to by the requirements owner(s).<br />
<br />
If there is already coverage in existing test suites, explicitly document it here.<br />
<br />
Often, a feature by itself will work fine, but when combined with existing functionality or other new features, it may not work correctly.  So ensure this type of testing is covered in the test coverage.  This implies that other new features being developed for the release should also be understood.   <br />
<br />
Backward compatibility, portability, and any other migration Issues should be considered.  One of the main complaints from customers is migrating from release to release (or from one platform to another).  <br />
<br />
Document any dependancies or open issues with the feature, so these are not over-looked.}%<br />
<br />
--------------------------------------------------------------------------------------------------------------<br />
<font size="4">The testing will be divided into diagnostic and functional testing. Testing will focus on the following main areas.</font><br />
<br />
<font size="5"><strong>Section I. Functional Testing</strong></font><br />
<ul>
    <li><font size="4">Define different levels of extensible derived types which have extensions from base type to different levels of extended child types. </font></li>
    <li><font size="4">Use these extensible derived types to define allocatable scalars and arrays. </font></li>
    <li><font size="4">Extensible derived types have different levels of extensions and contain components with different intrinsic types<font size="3">, <font size="4">such as </font></font><br />
    </font>
    <ul>
        <li><font size="4">     <a class="review" title="Click on the text to add a comment"><span id="line__145">integer(kind = 1, 2, 4, 8),</span></a><span id="comments_145"></span><span id="comments_entry_145"></span></font></li>
        <li><font size="4">     <a class="review" title="Click on the text to add a comment"><span id="line__146">         logical(kind = 1, 2, 4, 8),</span></a><span id="comments_146"></span><span id="comments_entry_146"></span></font></li>
        <li><font size="4">     <a class="review" title="Click on the text to add a comment"><span id="line__147">         </span></a><a class="review" title="Click on the text to add a comment"><span id="line__150">character(LEN = 1 and more)</span></a><span id="comments_150"></span><span id="comments_entry_150"></span></font></li>
    </ul>
    </li>
    <li><span id="comments_138"><span id="comments74695"><span id="expanded74695"><span id="comments_content74695"><a class="review" title="Click on the text to add a comment"><span id="line_74695_1"><font size="4">The derived type can have allocatable or pointer components.</font></span></a><span id="comments74695_1"></span><span id="comments_entry74695_1"></span><font size="4"> </font><a class="review" title="Click on the text to add a comment"><span id="line_74695_2"><font size="4">Also, the derived type can have a component that is of another derived type. </font></span></a></span></span></span></span></li>
    <li><font size="4">Allocatable arrays are defined with different levels of extensible derived types, and have different ranks, extents and bounds.</font></li>
    <li><font size="4"> LHS and RHS can have the following different combinations:</font></li>
</ul>
<ol>
    <li><font size="4">LHS is a scalar,&nbsp; RHS is a scalar.</font></li>
    <li><font size="4">LHS is an array, RHS is an array.</font></li>
    <li><font size="4">LHS is an array, RHS is a scalar.</font></li>
    <li><font size="4">LHS is a base type, RHS is a base type.</font></li>
    <li><font size="4">LHS is a base type, RHS is a child type.</font></li>
    <li><font size="4">LHS is a child type, RHS is a base type.</font></li>
    <li><font size="4">LHS and RHS are both child types, LHS is a parent type of RHS.</font></li>
    <li><font size="4">LHS and RHS are both child types, LHS is a not parent type of RHS.</font></li>
    <li><font size="4">LHS and RHS are both child types, RHS is a parent type of LHS.</font></li>
    <li><font size="4">LHS and RHS are both child types, RHS is a not parent type of LHS.</font></li>
    <li><font size="4">LHS and RHS have the same type containing the same components.</font></li>
    <li><font size="4">LHS and RHS have different types and contain different components.</font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS and RHS are both base types with the same extents but different bounds.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS and RHS are both base types but with different extents.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS is base type, but RHS is child type and have the same shape.<br />
    </font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS is base type, RHS is child type, but they have different shapes.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS and RHS are both base types with the same extents but different bounds.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS and RHS are both base types but with different extents.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS is base type, but RHS is child type and have the same shape.<br />
    </font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank one</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank one</font>, </font>LHS is base type, RHS is child type, but they have different shapes.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank two</font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS and RHS are both base types with the same extents but different bounds.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS and RHS are both base types but with different extents.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS is base type, but RHS is child type and have the same shape.<br />
    </font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an unallocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS is base type, RHS is child type, but they have different shapes.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS and RHS are both base types with the same extents but different bounds.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS and RHS are both base types but with different extents.</font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS is base type, but RHS is child type and have the same shape.<br />
    </font></font></li>
    <li><font size="4">LHS is </font><font size="4"><font size="4">an allocated array</font></font><font size="4"><font size="4"><font size="4"> with rank </font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font></font><font size="4"><font size="4"><font size="4">RHS is an allocated array</font></font></font><font size="4"><font size="4"><font size="4"><font size="4"> with rank </font></font></font></font><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4"><font size="4">two</font></font></font></font>, </font>LHS is base type, RHS is child type, but they have different shapes.</font></font></li>
    <li><font size="4"><font size="4">LHS is an array section, RHS is an array section, and they have the same shape.</font></font></li>
    <li><font size="4"><font size="4">LHS is an array, RHS is an array section, and they have the same shape.</font></font></li>
    <li><font size="4"><font size="4">LHS is an array section, RHS is an array section, and they have different shapes.</font></font></li>
    <li><font size="4"><font size="4">LHS is an array, RHS is an array section</font></font><font size="4"><font size="4">, and they have different shapes.</font></font></li>
    <li><font size="4"><font size="4">LHS is an array section, RHS is an array section, and they have different types.</font></font></li>
    <li><font size="4"><font size="4">LHS is an array, RHS is an array section</font></font><font size="4"><font size="4">, and they have different types.</font></font></li>
    <li><font size="4">LHS is an unlimited polymorphic array component, but RHS is an intrinsic array.&nbsp;</font></li>
    <li><font size="4">LHS variable is unlimited polymorphic entity, RHS expression is a function returning an allocatable object.</font></li>
    <li><font size="4">LHS is an unlimited polymorphic scalar, RHS is an object of a derived type which is also an element of an array. <br />
    </font></li>
    <li><font size="4">LHS is an unlimited polymorphic array section, RHS is an integer.</font></li>
</ol>
<font size="5"><strong>Section II. Diagnostic Testing</strong></font><font size="4">&nbsp;&nbsp;&nbsp; </font><br />
<font size="4">Test the following illegal cases.</font><br />
<ol>
    <li><font size="4"><font size="4">A<span id="comments74260"><span id="expanded74260"><span id="comments_content74260"> language level test case</span></span></span></font> <font size="4">to check different language standards such as </font>2003std, 95std, 90std and 77std.</font><br />
    <font size="4">     </font>     </li>
    <li><font size="4">LHS rank=1, RHS rank=2.</font></li>
    <li><font size="4">LHS rank=2, RHS rank=1.</font></li>
    <li><font size="4">LHS is an unallocated </font><font size="4"><font size="4">allocatable </font>scalar,&nbsp; RHS is an </font><font size="4"><font size="4">unallocated </font><font size="4"><font size="4">allocatable </font></font>array with rank 1.</font></li>
    <li><font size="4">LHS is an unallocated </font><font size="4"><font size="4">allocatable </font>scalar,&nbsp; RHS is an </font><font size="4"><font size="4">allocated </font>array</font><font size="4"><font size="4"> with</font> rank 1.</font></li>
    <li><font size="4">LHS are </font><font size="4"><font size="4">unallocated </font></font><font size="4"><font size="4">allocatable </font>scalars,&nbsp; RHS are </font><font size="4"><font size="4"><font size="4">unallocated </font><font size="4"><font size="4">allocatable </font></font></font>arrays</font><font size="4"><font size="4"> with</font> rank 2.</font></li>
    <li><font size="4">LHS are </font><font size="4"><font size="4">unallocated </font></font><font size="4"><font size="4">allocatable </font>scalars,&nbsp; RHS are </font><font size="4"><font size="4"><font size="4">allocated </font></font>arrays</font><font size="4"><font size="4"> with</font> rank 2.</font></li>
    <li><font size="4">LHS is an allocated</font><font size="4"><font size="4"> </font>scalar,&nbsp; RHS is an </font><font size="4"><font size="4">unallocated </font><font size="4"><font size="4">allocatable </font></font>array</font><font size="4"><font size="4"> with</font> rank 1.</font></li>
    <li><font size="4">LHS is an allocated</font><font size="4"><font size="4"> </font>scalar</font><font size="4">,&nbsp; RHS is an </font><font size="4"><font size="4">allocated </font>array</font><font size="4"><font size="4"> with</font> rank 1.</font></li>
    <li><font size="4">LHS are </font><font size="4"><font size="4">allocated</font></font><font size="4"><font size="4"> </font>scalars,&nbsp; RHS are </font><font size="4"><font size="4"><font size="4">unallocated </font><font size="4"><font size="4">allocatable </font></font></font>arrays</font><font size="4"><font size="4"> with</font> rank 2.</font></li>
    <li><font size="4">LHS are </font><font size="4"><font size="4">allocated</font></font><font size="4"><font size="4"> </font>scalars,&nbsp; RHS are </font><font size="4"><font size="4"><font size="4">allocated </font></font>arrays</font><font size="4"><font size="4"> with</font> rank 2.</font></li>
    <li><font size="4">LHS is a base type allocatable scalar, not a class allocatable scalar, RHS is a derived type scalar.</font></li>
    <li><font size="4">LHS is a base type of pointer, not allocatable, RHS is an object of base type.</font></li>
    <li><font size="4">LHS is a base type of pointer, not allocatable, RHS are allocatable scalars with class and type attributes.</font></li>
    <li><font size="4">LHS is a allocatable base type scalar, RHS is a derived type which is not a child of the base type.</font></li>
</ol>
<p style="MARGIN: 0in 0in 0pt">&nbsp;<br />
</p>
<font size="3"> </font>
<p>
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#bfbfff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="font-family: Arial; font-size: 12pt;"><strong>Test Procedure and Scenario</strong></td>
        </tr>
    </tbody>
</table>
</p>
%Note{A Test procedure provides detailed instructions for the execution of one or more test cases.  <br />
<br />
Most good software development models call for both a Test Plan and a Test Procedure document. <br />
Although in principle this sounds good, test procedures are costly to develop and maintain.  When writing test cases, Test procedures often require updating, requiring IT1 [test plan] to be re-opened.<br />
<br />
Currently, development teams review this section, and not necessarily the test cases themselves.  So there is definitely value in having this information available.  If it is not provided in the IT1 document, it needs to be provided during test case review, and reviewed by developer.  <br />
.}%<br />
<br />
<font size="4">Test cases will be listed in the corresponding&nbsp; IT2 document.</font><br />
<p>
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#bfbfff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="font-family: Arial; font-size: 12pt;"><strong>Test cases Information</strong></td>
        </tr>
    </tbody>
</table>
</p>
%Note{This section details the test case location and other test case related information<br />
<br />
Technically, this is not part of a &quot;Test plan&quot;.  <br />
<br />
Following information may not be known during IT1 time-frame.  If it's known, it should be documented:<br />
Document information about release name. component name. cmvc location and test cases shadow location<br />
<br />
Document information about the feature bucket structure.  If the feature is big enough, sub-buckets will be necessary to maintain some organization. <br />
<br />
Document  information about the feature test case naming convention.  <br />
Example: <br />
xxx_001f.scenario (functional) <br />
xxx_001d.scenario (diagnostic) <br />
where xxx can be the feature name or function name that the test case is testing. <br />
<br />
<br />
If you plan to have a combined IT1 and test case review, further test case information needs to be added to this section:<br />
Following statement needs to be added::<br />
&quot;Test case approval will also be done through this document, so no formal test case review document will be published.<br />
Please review the test cases from the location provided below, and only approve this document if you are satisfied with <br />
the IT1 (test plan) and the test cases.&quot; <br />
List of test case names, so that comments can be added per test case; if there are too many test cases, list groups of test cases, or test lists.}%<br />
<br />
<font size="4">Location of test cases:<br />
CMVC Family:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aix@aix.torolab.ibm.com@1500<br />
CMVC Component:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xlftest.F2008<br />
CMVC Release:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tstdev,&nbsp; tst151<br />
CMVC path:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;release&gt;/F2008/polyAssign/func<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;release&gt;/F2008/polyAssign/diag<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;release&gt;/F2008/polyAssign/doc</font><br />
<p>
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#bfbfff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="font-family: Arial; font-size: 12pt;"><strong>Build Sanity Candidate(s)</strong></td>
        </tr>
    </tbody>
</table>
</p>
%Note{List one or more test cases that are to be added to the BDS test list.  <br />
<br />
If the test cases are already identified during IT1 time-frame, it should be documented here.<br />
<br />
BDS test candidates may not be known until test case review time-frame.&nbsp; Thus not identifying the candidate during IT1 time-frame does not prevent it from being approved.  For this case, a URL  link to RTC task must exist.<br />
<br />
Not all features require test cases to be added to BDS.  This must be explicitly stated here (or in RTC task if not known during IT1 time-frame).<br />
}%<br />
<br />
<font size="4">There will be test cases for build sanity.</font><br />
<font size="3">They will be in IT2 and the master story 96086.</font><br />
<p>
<table width="100%" cellspacing="0" cellpadding="5" border="1" bgcolor="#bfbfff">
    <tbody>
        <tr>
            <td width="100%" valign="top" align="center" style="font-family: Arial; font-size: 12pt;"><strong>Reference</strong></td>
        </tr>
    </tbody>
</table>
</p>
%Note{I0 Location and any references (including standards) that may help understand the IT1.}%<strong style="color: rgb(0, 128, 0); font-size: 20px;"><br />
<font size="5"><br />
</font></strong><font size="3"><span style="color: rgb(0, 128, 0); font-size: 20px;"><font size="5">No I0 for this feature as per RTC WI 96086.</font><br />
<br />
1. Fortran 2008 standard<br />
2. Master Story 96086: F2008: LHS of intrinsic assignment is allowed to be polymorphic<br />
&nbsp;&nbsp;&nbsp; https://compjazz.torolab.ibm.com:9443/jazz/resource/itemName/com.ibm.team.workitem.WorkItem/96086</span></font><strong style="color: rgb(0, 128, 0); font-size: 20px;"><br />
<strong style="color: rgb(0, 128, 0); font-size: 20px;"><strong style="color: rgb(0, 128, 0); font-size: 20px;"><strong style="color: rgb(0, 128, 0); font-size: 20px;"></strong></strong></strong> </strong><!--HTML Wrapper--></body></html>